%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LATEX-TEMPLATE TECHNISCH RAPPORT
%-------------------------------------------------------------------------------
% This template is derived from the AVI PT report template.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%-------------------------------------------------------------------------------
%	PACKAGES EN DOCUMENT CONFIGURATIE
%-------------------------------------------------------------------------------

\documentclass{uva-inf-article}
%\usepackage[dutch]{babel}
%\usepackage{csquotes}

\usepackage[style=numeric-comp]{biblatex}
\addbibresource{PT-essay.bib}
\usepackage{listings}
%-------------------------------------------------------------------------------
%	GEGEVENS VOOR IN DE TITEL
%-------------------------------------------------------------------------------

% Vul de naam van de opdracht in.
\assignment{Compiler Construction}
% Vul het soort opdracht in.
\assignmenttype{Essay}
% Vul de titel van de eindopdracht in.
\title{CiviC Compiler Report}

% Vul de volledige namen van alle auteurs in.
\author{René Kok}
\uvanetid{13671146}

\author{Aram Mutlu}
\uvanetid{13574116}

% Vul eventueel ook de naam van de docent of vakcoordinator toe.
\docent{Dhr. dr. C.U. Grelck}
\course{Compiler Construction}
% Te vinden op onder andere Datanose.
\courseid{5062COMP6Y}

% Dit is de datum die op het document komt te staan. Standaard is dat vandaag.
\date{\today}

%-------------------------------------------------------------------------------
%	VOORPAGINA
%-------------------------------------------------------------------------------

\begin{document}
\maketitle

%-------------------------------------------------------------------------------
%	INHOUDSOPGAVE EN ABSTRACT
%-------------------------------------------------------------------------------

% Niet doen bij korte verslagen en rapporten
%\tableofcontents
%\begin{abstract}
%\lipsum[13]
%\end{abstract}

%-------------------------------------------------------------------------------
%	INTRODUCTIE
%-------------------------------------------------------------------------------

\section{Introduction}
\par This report provides information regarding the CiviC compiler we build in 
the course Compiler Construction by dr. C.U. Grelck. The goal of the CiviC compiler 
is to create a CiviC compiler that transforms CiviC code into CiviC assembly code 
that a computer can understand. In this report we will focus on different aspects 
of our compiler and what we did and how we did it. We will do this by following the order of the milestones,
from scanning/parsing to code generation and also use the milestones to further 
explain the compiler.

We didn't implement any of the extensions and optimizations beyond the standard 
milestones for a functional compiler.

%-------------------------------------------------------------------------------
%	METHODE
%-------------------------------------------------------------------------------
\newpage
\section{Lexicographic Analysis}
The first step for building a CiviC compiler is to create (or extend in this case) 
the scanner that reads the CiviC code (stream of characters) that recognizes the 
symbols and words and outputs a (finite) stream of tokens.
By recognizing the words and symbols the Scanner can use pattern matching to find see
what the next action will be for the compiler. For the scanner to know which symbols
are available in the CiviC language, we need to define these ourselves. We did this 
by defining all the possible symbols (parenthesis, brackets and binary operators etc.)
which are supported by the CiviC language. The CiviC language only supports integers,
floats and booleans so there is no need to define other types in the compiler.

% TODO: vertel dat we #include "limits.h" hebben gebruikt voor de min en max.
% ^Done, maar niet zeker of t goed is hieronder
In our scanner we added a validator that validates if an integer is too large or too small by 
comparing it to the max int and min int. We included the "limits.h" file in our civic.l
to get the values of min and max. If the integer is too high or too low the compiler
returns an CTIerror telling the integer is out of range.

\begin{lstlisting}[basicstyle=\small, language=C, label=lst:code, caption=Integer range check, captionpos=b]
    [0-9]+      { long integer = strtol(yytext, NULL, 10);
                    if (integer > INT_MAX || integer < INT_MIN) {
                        CTIerror("Integer %s out of range", yytext);
                    }
                    else
                    {
                        yylval.cint=atoi(yytext);
                        FILTER( INTVAL);
                    }
                }
\end{lstlisting}

% TODO: Extra check max float value.


% TODO: Check Milestone 2
After completing the scanner we needed to refine our intermediate representation (abstract
syntax tree) for our compiler. We used the AST that was provided by school and added some 
elements of our own. To make the SymbolTable work properly we added the SymbolTable to the
AST along with the SymbolTableEntry. A SymbolTableEntry contains all the information about 
an entry such as in which SymbolTable its stored in, name, type, if its a function/parameter/export,
its offset, depth and its definition. We did the same for the CodeGenTable and the CodeGenTableEntry.
The CodeGenTableEntry stores information for a single line of code generation such as the
index, instruction and the value of the generated code. Code generation will be further 
explained in section 6 of this report.

% TODO: (maybe expand) Milestone 3
To properly illustrate the logical structure of the code we had to expand the print traversals
to cover the full syntactic range of the CiviC language. Each node in the AST has its own
print traversal which prints the information of the specific node in the Print AST phase.



\newpage
\section{Syntatic Analysis}
After the scanner is done and creates a (finite) stream of tokens, the parser comes
into play and will start its job. The parser will use the output from the scanner and
use it to create and output an abstract syntax tree (AST). The parser uses the stream 
of tokens to do pattern matching with the pre defined casus in the compiler. 

The parser does all the pattern matching for us. For each node in the AST we created 
a new node with its pattern in civic.y so the parser can match them. The civic.y is a
YACC file which stands for "Yet Another Compiler Compiler” and auto-generates parsers
from context-free grammars. The YACC file contains all patterns with their corresponding
actions to perform.

Listing 2 shows a simple example of pattern matching. In this example we added the
node with its pattern so the pattern matching visible. 

\begin{lstlisting}[basicstyle=\small, language=C, label=lst:code, caption=Pattern matching Example, captionpos=b]

int b;          // globdef: type ID SEMICOLON

void foo() {    // fundef: type ID PARENTHESIS_L PARENTHESIS_R  CURLY_L
                    // funbody (inside curly brackets)
    int a = 2;      // vardecl: type ID LET expr SEMICOLON
    b = 1;          // assign: varlet LET expr SEMICOLON (varlet: ID)
}               // CURLY_R 
\end{lstlisting}

At the end of the civic.y YACC file we added an error function that prints an error message
with CTIabort so the user can see where the error came from (line + col number) and what
the error message is. 

\section{Context Analysis}
% TODO: René
Semantic Analysis consists of 2 parts: the context analysis and the type checker. The context
analyser uses the output from the parser (the AST) and outputs an AST with symbol tables. the
type checker checks for example if a value can be assigned to a certain type. 

The context analyser (CA) starts with creating a symbol table for the program. After creating the
symbol table the CA walks through the AST and calls the corresponding CA node function to create 
a new SymbolTableEntry for the node.

\section{Code transformations}
% TODO: Milestone 6, 9, 10 en for-loop variable initializing (Milestone 5) en for- to while loop

\newpage
\section{Code Generation}
\par The last stage of the compiler, the bytecode generation, is converting the abstract syntax tree into assembly code. 
With this assembly code, the virtual machine specially designed for Civic can execute the given Civic code.

\par The whole code generation is done in a single traversal named "Generate byte code".
The default traversal mode of the code generation is set to "user", because almost all nodes are traversed.
There are a few code generation methods that do nothing, and immediately return the node. 
These methods were necessary because without these methods the compiler would not compile because the user specified traversal expects one method for each AST node.

\par A special code generation table and code generation table entry has been designed for saving and printing the global variables, constants, imports and exports. 
The code generation table consists of 4 child nodes in which these instructions are stored.

\par Generating the bytecode is done in a fairly simple way.
The abstract syntax tree is traversed and based on certain flags and attributes and of the different 
nodes instructions are printed and/or added to the correct code generation table.
After the AST has been traversed and the main instructions have been printed, the global variables, constants, 
imports and exports instructions (which are stored in the code generation table) are printed.

\section{Conclusion/Discussion/Reflection}
\par The last section of your report should be reflective and could be called
anything along the lines of Conclusions, Discussion or Reflection. 

%-------------------------------------------------------------------------------
%	REFERENTIES
%-------------------------------------------------------------------------------

%\printbibliography

%-------------------------------------------------------------------------------
%	BIJLAGEN EN EINDE
%-------------------------------------------------------------------------------

%\section{Bijlage A}
%\section{Bijlage B}
%\section{Bijlage C}
\end{document}
